{
    "collab_server" : "",
    "contents" : "---\ntitle: Article - The 5 verbs of dplyr\nauthor: Ben\ndate: '2017-09-19'\nslug: the-5-verbs-of-dplyr-article\noutput: \n  github_document:\n    toc: true\n---\n\n# Getting started\n\nAs always, the first thing we will do is load the tidyverse. \n\n_Note: If you haven't yet installed the tidyverse, you'll first have to run the code install.packages(\"tidyverse\")._\n\n```{r message = FALSE}\nlibrary(tidyverse)\n```\n\nThe Tidyverse is a collection of packages made by Hadley Wickham.  One of the key packages in that collection is called dplyr. Think of the d as standing for data and the plyr standing for plyers -- the goal of this package is to manipulate data frames in useful ways.\n\nThe magic of dplyr is that with just a handful of commands (the verbs of dplyr), you can do nearly anything you'd want to do with your data.\n\nThis article will cover the five verbs of dplyr: select, filter, arrange, mutate, and summarize.\n\nBefore we walk through each command, let's make a data frame to play with.\n\n```{r}\nhamsters <- data_frame(name = c(\"Megan\", \"Amy\", \"Jen\", \"Karl\", \"Jeremy\"),\n\t\t\t     gender = c(\"female\", \"female\", \"female\", \"male\", \"male\"),\n\t\t\t     hamsters = c(5, 7, 6, 2, 1),\n\t\t\t     hamster_cages = c(2, 1, 3, 3, 4))\n```\n\nDon't worry too much about the above code, but you might stop and inspect it. Notice that\nwe're creating a data frame named hamsters. The first column is name and then we list the names. The\nc stands for concatenate and its how we stick multiple things together. All strings (aka words) need to have quotes around them. The second column is gender and so on.\n\nBy just running the name of the data frame, hamsters, it will show it to us\nand tell us a little bit about it. The 7 x 4 says it has 7 rows and 4 columns.\nEach column has a type: name and gender are <chr> which stands for characters,\nand the other columns are <dbl> which stands for double and is another word for number.\n\n```{r}\nhamsters\n```\n\nNow that we have a data frame to work with, we can dive into the 5 verbs of dplyr. The code blocks below will show small little examples of what is possible. Before doing something with hamsters, I'll typically print the original hamsters data frame first because the easiest way to see what a function is doing is to see a before and after.\n\n# Arrange\n\nArrange keeps all of the information in the data frame, but just changes the order of the rows. This is the same thing that the \"sort\" feature in Excel does.\n\nBy default, arranging happens in ascending order or from low to high:\n\n```{r}\nhamsters\n\nhamsters %>% \n  arrange(hamsters)\n```\n\nWe can instead arrange in descending order with the desc() function:\n\n```{r}\nhamsters %>% \n  arrange(desc(hamster_cages))\n```\n\nCharacter columns get arranged in alaphetical order:\n\n```{r}\nhamsters %>% \n  arrange(name)\n```\n\nIf we input multiple column names, arrange uses the additional columns to break ties.\n\n**Self-explanation: Why do Karl and Jen switch positions in the following two data frames?**\n\n```{r}\nhamsters %>% \n  arrange(hamster_cages)\n\nhamsters %>% \n  arrange(hamster_cages, hamsters)\n```\n\n# Select\n\nSelect is used to choose which columns to work with. For example, maybe we want just the name and hamsters columns:\n\n```{r}\nhamsters\n\nhamsters %>% \n  select(name, hamsters)\n```\n\nWe can use a \"-\" to get rid of a column and leave the rest of the columns:\n\n```{r}\nhamsters\n\nhamsters %>% \n  select(-name)\n```\n\nWe also could have gotten just the name and hamsters columns by removing the gender and hamster_cages columns:\n\n```{r}\nhamsters\n\nhamsters %>% \n  select(-gender, -hamster_cages)\n```\n\nSelect can also be used to rearrange the order of columns:\n\n```{r}\nhamsters\n\nhamsters %>% \n  select(hamsters, hamster_cages, gender, name)\n```\n\neverything() is a convenient shortcut that adds all the columns that haven't been used yet. It is very useful if you want to move a column to the front of a data frame:\n\n```{r}\nhamsters\n\nhamsters %>% \n  select(hamster_cages, everything())\n```\n\n# Filter\n\nFilter is used to select which rows you want. For example, maybe we only want students with more than 3 hamsters:\n\n```{r}\nhamsters\n\nhamsters %>% \n  filter(hamsters > 3)\n```\n\n_(Notice that there is a variable named the same thing as the data frame. The first \"hamsters\" in the following code refers to the data frame, while the second \"hamsters\" refers to the hamsters column.)_\n\nOr maybe we only want female students:\n\n```{r}\nhamsters\n\nhamsters %>% \n  filter(gender == \"female\")\n```\n\nNotice that we had to use \"==\" instead of \"=\". This is because \"=\" is for assignemnt -- making something equal something else -- whereas \"==\" is for comparison -- seeing if two things are equal or not.\n\nIf we want to use an \"and\" (require that multiple conditions hold) we can either use the \"&\" sign or separate the conditions with a comma. For example, the following two filters are equivalent:\n\n```{r}\nhamsters %>% \n  filter(gender == \"female\" & hamsters >= 6)\n\nhamsters %>% \n  filter(gender == \"female\", hamsters >= 6)\n```\n\nIf we want to use an \"or\" (require that just 1 of multiple conditions holds) we have to use the | sign (hold \"shift\" and the key above the \"return\" key). For example:\n\n```{r}\nhamsters\n\nhamsters %>% \n  filter(gender == \"male\" | hamsters >= 7)\n```\n\nA case that commonly comes up is requiring that a variable has one of a set of specific values. For example, maybe we only want students with 2, 4, 6, or 8 hamsters. \n\nThe most intuitive way to do this is with a series of \"or\" statements:\n\n```{r}\nhamsters %>% \n  filter(hamsters == 2 | hamsters == 4 | hamsters == 6 | hamsters == 8)\n```\n\nIt gets tedious having to type and retype the word \"hamsters\" over and over again, though.\n\nA nice shortcut is to supply the values you're interested in as a vector by typing c(2, 4, 6, 8) -- the c stands for concatenate which basically means to glue 2 to 4 to 6 to 8 all together in one vector.\n\nOnce we have that vector we can simply check if the number of hamsters for that row is \"%in%\" the vector we created. Here's how that looks:\n\n```{r}\nhamsters\n\nhamsters %>% \n  filter(hamsters %in% c(2, 4, 6, 8))\n```\n\nThis can be a little bit confusing, so make sure you understand this. Think about the filter as happening row by row: first it checks the first row to see if 5 is in c(2, 4, 6, 8) -- it isn't so it doesn't include that row. Then it checks the second row and also doesn't include that one because 7 isn't in the vector. It then checks the third row and keeps it because 6 is in there, and so on.\n\n# Filter with groups\n\nGroups can be confusing at first but they are incredibly useful. Usually code operates on rows. For example, the code above checked each row to see if the gender was female in that row.\n\nBut sometimes we want to work with groups of rows instead of one row at a time. To do so, we add a group attribute to the data frame before we do anything.\n\nHere's example code and a visual depiction of grouping a data frame by the \"a\" column:\n\n```{r eval = FALSE}\ndataframe %>% \n   group_by(a)\n```\n\n![](/images/group_by.png)\n\n_Sourced from [R Bootcamp at Berkeley](https://github.com/berkeley-scf/r-bootcamp-2017)_\n\nThis sort of thinking is often called split-apply-combine: The idea is to split a data frame into multiple groups, apply something to each group, then combine the groups back into a single data frame.\n\nLet's look at an example with hamsters:\n\n```{r}\nhamsters\n\nhamsters %>% \n  group_by(gender) %>% \n  filter(max(hamster_cages) == 3)\n```\n\nWe first grouped by gender. After that, every operation will happen at the group level instead of the row level.\n\nThe final line is where the magic happens. It tells R to return only the gender group where the max number of hamster cages is 3. This is the female group.\n\nNotice that the male group isn't included because the max number of hamster cages is 4, not 3.\n\nSimilarly, we can get the gender group where the mean number of hamsters is 6. This time its the male group because there are two males -- one with 1 hamster and the other with 2 hamsters.\n\n```{r}\nhamsters \n\nhamsters %>% \n  group_by(gender) %>% \n  filter(mean(hamsters) == 1.5)\n```\n\nThe n() function is a shortcut for the number of rows in the group. So, the following code finds the gender group with 3 rows in it: \n\n```{r}\nhamsters \n\nhamsters %>% \n  group_by(gender) %>% \n  filter(n() == 4)\n```\n\nOf course, there isn't any reason that we have to group by gender. We could instead group by the number of hamster cages. \n\n**Self-explanation: Why don't Jen or Karl appear in the data frame after we filter?**\n\n```{r}\nhamsters\n\nhamsters %>% \n  group_by(hamster_cages) %>% \n  filter(n() == 1)\n```\n\n# Mutate\n\nSo far, arrange has sorted our data, select has chosen which columns to work with, and filter has sorted which rows to use. We haven't changed our data at all yet though -- that's what mutate does!\n\nFor example, maybe we want to create a new variable based on the number of hamsters per cage for each person:\n\n```{r}\nhamsters\n\nhamsters %>% \n  mutate(hamsters_per_cage = hamsters / hamster_cages)\n```\n\nNote that this is the first time we can start to combine the dplyr verbs to really make some magic happen!\n\n```{r}\nhamsters %>% \n  mutate(hamsters_per_cage = hamsters / hamster_cages) %>% \n  arrange(hamsters_per_cage)\n```\n\nOr maybe we want an indicator of if the person has 5 or more hamsters:\n\n```{r}\nhamsters %>% \n  mutate(five_or_more_hamsters = hamsters >= 5)\n```\n\nWe can also use mutate to input new data:\n\n```{r}\nhamsters %>% \n  mutate(cats = c(4, 5, 2, 3, 1))\n```\n\nOf course, this only works if we give it the right amount of values:\n\n```{r error = TRUE}\nhamsters %>% \n  mutate(dogs = c(1, 3, 5))\n```\n\nInterestingly, we can give it just 1 value and it will repeat it the correct number of times automatically:\n\n```{r}\nhamsters %>% \n  mutate(walruses = 0)\n```\n\nWe can create multiple new columns with one use of mutate if we separate each new column with a \",\":\n\n```{r}\nhamsters %>% \n  mutate(hamsters_per_cage = hamsters / hamster_cages,\n         five_or_more_hamsters = hamsters >= 5)\n```\n\nNotice that \"mutate\" leaves all of the original columns in the dataframe and adds new columns. If we instead use \"transmute\" we'll only get the new columns:\n\n```{r}\nhamsters %>% \n  transmute(hamsters_per_cage = hamsters / hamster_cages,\n         five_or_more_hamsters = hamsters >= 5)\n```\n\nSlightly more complex things can be done by using values calculated from the data frame in the creation of a new column.\n\n```{r}\nhamsters %>% \n  mutate(hamster_cages_centered = hamster_cages - mean(hamster_cages))\n```\n\nNotice that first the mean of the hamster_cages column is calculated to be 2.6, then the new column is created by subtracting 2.6 off of each value of the hamster_cages column.\n\n# Mutate with groups\n\nSometimes its useful to define new variables based on a group. Remember groups tell R to operate on the data frame one group at a time as opposed to using all of the rows in the data frame.\n\nFor example, examine the following -- note how it's different from the code above:\n\n```{r}\nhamsters %>% \n  group_by(gender) %>% \n  mutate(hamster_cages_centered_by_gender = hamster_cages - mean(hamster_cages))\n```\n\nBefore in \"hamster_cages_centered\" we subtracted the mean of hamster_cages which was 2.6 off of every value of hamster_cages.\n\nNow because we are grouping by gender, we subtract 2 off of hamster_cages for females and 3.5 off of hamster_cages for males. This is because mean(hamster_cages) operates on groups of rows defined by gender after we add the \"group_by(gender)\" attribute to the data frame.\n\n**Challenge: See if you can understand what the following code is doing. Warning, the \"new_varible\" doesn't really make sense context.**\n\n```{r}\nhamsters %>% \n  group_by(hamster_cages) %>% \n  mutate(new_variable = hamster_cages - n())\n```\n\n# Summarize\n\nMutate kept the same number of rows in the data frame and added a column.\n\nWe also want to be able to collapse rows of a data frame which we might think of summarizing. One of the most common ways to summarize a set of numbers is to take the mean:\n\n```{r}\nhamsters\n\nhamsters %>% \n  summarize(hamsters_mean = mean(hamsters))\n```\n\nAnother common method of summarizing is the median. We can summarize multiple variables with multiple functions at the same time:\n\n```{r}\nhamsters %>%\n  summarize(hamsters_mean = mean(hamsters),\n            hamsters_median = median(hamsters),\n            hamster_cages_mean = mean(hamster_cages),\n            hamster_cages_median = median(hamster_cages))\n```\n\n# Summarize with groups\n\nSummarize isn't that useful by itself, but when we add groups it becomes crazy powerful! \n\nIt allows us to get a summary row for each group in the data frame:\n\n```{r}\nhamsters\n\nhamsters %>% \n  group_by(gender) %>% \n  summarize(mean_hamsters = mean(hamsters))\n```\n\nJust as before, we can create multiple summary statistics all at once:\n\n```{r}\nhamsters %>% \n  group_by(gender) %>% \n  summarize(mean_hamsters = mean(hamsters),\n            max_hamsters = max(hamsters),\n            count = n())\n```\n\nOf course, we don't have to group by gender (it just happens to be the most natural in this case):\n\n```{r}\nhamsters %>% \n  group_by(hamster_cages) %>% \n  summarize(max_hamsters = max(hamsters),\n            count = n())\n```\n\nIt is easy to get the difference between mutate and summarize confused. Remember that mutate returns the same number of rows in a data frame, summarize returns just one row, and summarize with groups returns a row for each group.\n\n# The power of combining verbs!\n\nThe true power of dplyr comes from combining these 5 verbs to solve problems. For example, see how we can piece commands together to do more and more complex operations:\n\n```{r}\nhamsters %>%\n  arrange(hamsters)\n\nhamsters %>%\n  arrange(hamsters) %>% \n  select(-name) \n\nhamsters %>%\n  arrange(hamsters) %>% \n  select(-name) %>% \n  mutate(walruses = 0) \n\nhamsters %>%\n  arrange(hamsters) %>% \n  select(-name) %>% \n  mutate(walruses = 0) %>% \n  group_by(gender) %>% \n  mutate(hamsters_centered_by_gender = hamsters - mean(hamsters))\n\nhamsters %>%\n  arrange(hamsters) %>% \n  select(-name) %>% \n  mutate(walruses = 0) %>% \n  group_by(gender) %>% \n  mutate(hamsters_centered_by_gender = hamsters - mean(hamsters))\n```\n\n# A few more examples\n\nThere are many little tricks that dplyr can do that we haven't talked about. Below are a few of those.\n\nGrouping and summarizing to get counts is so common that there is a shortcut \"count\" function:\n\n```{r}\nhamsters %>% \n  group_by(gender) %>% \n  summarise(n = n())\n\nhamsters %>% \n  count(gender)\n```\n\nIf you're working with a lot of columns, select has some really useful helper functions. For example, we can get all of the columns that start with the letter \"h\":\n\n```{r}\nhamsters %>% \n  select(starts_with(\"h\"))\n```\n\nSometimes people will use mutate to create a variable and then use that new variable to filter, but you can just put that variable definition as the filter condition:\n\n```{r}\nhamsters %>% \n  mutate(more_than_5_hamsters_OR_2_cages = hamsters > 5 | hamster_cages > 3) %>% \n  filter(more_than_5_hamsters_OR_2_cages)\n\nhamsters %>% \n  filter(hamsters > 5 | hamster_cages > 3)\n```\n\nMaybe you want the person with the fewest number of hamsters by gender:\n\n```{r}\nhamsters %>% \n  arrange(hamsters) %>% # can you figure out why we need this arrange?\n  group_by(gender) %>% \n  summarise(fewest_hamsters = first(hamsters))\n```\n\nIf we want to keep the entire row, we can use the \"slice\" function to slice out the first row:\n\n```{r}\nhamsters %>% \n  arrange(hamsters) %>% # can you figure out why we need this arrange?\n  group_by(gender) %>% \n  slice(1)\n```\n# Future improvements and other resources\n\nTo add in the future... at/if/all, rolling off multiple groups, ...\n\nThis [cheatsheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf) is a great way of seeing all of the functions at once. Some data scientists work with it on their desk.\n\n[R for data science](http://r4ds.had.co.nz/transform.html), [stats 545](http://stat545.com/block010_dplyr-end-single-table.html), and [Simon Ejdemyr's website](https://stanford.edu/~ejdemyr/r-tutorials/modifying-data/) all have thoughtful writing and exercises on more advanced features of dplyr.\n```",
    "created" : 1509142217974.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1126745071",
    "id" : "A7AF6F05",
    "lastKnownWriteTime" : 1509142401,
    "last_content_update" : 1509142401535,
    "path" : "~/Google Drive/Projects/Data Science Tutoring/githubr_curriculum/the-5-verbs-of-dplyr-article.Rmd",
    "project_path" : "the-5-verbs-of-dplyr-article.Rmd",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}